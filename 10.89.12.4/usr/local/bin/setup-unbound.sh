#!/usr/bin/env bash
# setup-unbound.sh
# sudo /usr/local/bin/setup-unbound.sh
# Idempotent Unbound recursive DNS resolver setup script
#
# ‚ö†Ô∏è AUTOGENERATED by /home/julie/homelab/scripts/setup-homelab.sh
# DO NOT EDIT ‚Äî changes will be overwritten by homelab automation
#
# to deploy use
#     sudo cp /home/julie/homelab/10.89.12.4/usr/local/bin/setup-unbound.sh /usr/local/bin/;sudo chown root:root /usr/local/bin/setup-unbound.sh;sudo chmod 700 /usr/local/bin/setup-unbound.sh
#
# Prerequisites:
#   - Requires root privileges (sudo).
#   - Unbound installed and systemd unit enabled.
#
# Usage:
#   sudo setup-unbound.sh   # generates /etc/unbound/unbound.conf and restarts Unbound
#
# Short notes:
# - Writes a clean recursive resolver config to /etc/unbound/unbound.conf.
# - Ensures root hints and DNSSEC trust anchor are referenced.
# - Restarts Unbound service to apply changes.
# - Safe to run multiple times (idempotent).
# - Recommended to run periodically (cron/systemd timer) for resilience.

set -euo pipefail

conf_file="/etc/unbound/unbound.conf"

# Detect ULA IPv6 addresses on bridge0 (configured by UGOS UI)
IFACE="bridge0"
ULAS=$(ip -6 addr show dev "$IFACE" | awk '/inet6 fd/ {print $2}')

# Build interface lines dynamically for ULAs
ULA_INTERFACES=""
for addr in $ULAS; do
    ip_only=${addr%%/*}   # strip /64
    ULA_INTERFACES+="    interface: $ip_only
"
done

desired_conf=$(cat <<EOF
# ‚ö†Ô∏è AUTOGENERATED by setup-unbound.sh
# DO NOT EDIT ‚Äî changes will be overwritten by homelab automation

server:
    interface: 127.0.0.1
    interface: ::1
    interface: 10.89.12.4
$ULA_INTERFACES

    access-control: 127.0.0.0/8 allow          # IPv4 loopback (entire reserved loopback block, useful for testing, multiple local bindings, or distro quirks)
    access-control: ::1 allow                  # IPv6 loopback
    access-control: 10.89.12.0/24 allow        # LAN IPv4
    access-control: fd10:8912:0:0::/64 allow   # LAN ULA IPv6
    access-control: fd7a:115c:a1e0::/48 allow  # Tailscale ULA IPv6
    access-control: 100.64.0.0/10 allow        # Tailscale IPv4
    access-control: 10.1.0.0/24 allow          # wg1
    access-control: 10.3.0.0/24 allow          # wg3
    access-control: 10.5.0.0/24 allow          # wg5
    access-control: 10.7.0.0/24 allow          # wg7
    access-control: fd10:4::/64 allow          # wg4 IPv6
    access-control: fd10:5::/64 allow          # wg5 IPv6
    access-control: fd10:6::/64 allow          # wg6 IPv6
    access-control: fd10:7::/64 allow          # wg7 IPv6

    num-threads: 6
    msg-cache-size: 128m
    rrset-cache-size: 256m
    key-cache-size: 64m
    neg-cache-size: 4m
    prefetch: yes
    prefetch-key: yes
    hide-identity: yes
    hide-version: yes
    qname-minimisation: yes

    root-hints: "/etc/unbound/root.hints"
    auto-trust-anchor-file: "/etc/unbound/root.key"
    do-not-query-localhost: no

remote-control:
    control-enable: yes
    control-interface: 127.0.0.1
    control-port: 8953
    server-key-file: /etc/unbound/unbound_server.key
    server-cert-file: /etc/unbound/unbound_server.pem
    control-key-file: /etc/unbound/unbound_control.key
    control-cert-file: /etc/unbound/unbound_control.pem
EOF
)

# Write config if missing or outdated
if [ ! -f "$conf_file" ] || ! diff -q <(echo "$desired_conf") "$conf_file" >/dev/null; then
    echo "‚úçÔ∏è Writing Unbound config to $conf_file"
    echo "$desired_conf" | sudo tee "$conf_file" >/dev/null
else
    echo "‚úÖ Unbound config already up-to-date at $conf_file"
fi
if [ "$(stat -c %U:%G $conf_file)" != "root:root" ]; then
    sudo chown root:root "$conf_file"
fi
if [ "$(stat -c %a $conf_file)" != "644" ]; then
    sudo chmod 0644 "$conf_file"
fi

# Validate config (always run to catch errors)
if ! output=$(sudo unbound-checkconf "$conf_file" 2>&1); then
    echo "‚ùå Command failed: sudo unbound-checkconf $conf_file"
    echo "Error output:"
    echo "$output"
    echo "‚ö†Ô∏è Skipping restart/reload due to invalid config"
    exit 1
fi

# Ensure root hints and trust anchor files exist
for f in /etc/unbound/root.hints /etc/unbound/root.key; do
    if [ ! -s "$f" ]; then
        echo "‚ùå Required file missing or empty: $f"
        exit 2
    fi
    # Fix ownership and permissions if needed
    if [ "$(stat -c %U:%G $f)" != "unbound:unbound" ]; then
        echo "üîß Fixing ownership of $f to unbound:unbound"
        sudo chown unbound:unbound "$f"
    fi
    if [ "$(stat -c %a $f)" != "644" ]; then
        echo "üîß Fixing permissions of $f to 644"
        sudo chmod 0644 "$f"
    fi
done

# Block of AppArmor read rules required for Unbound remote-control TLS key/cert files.
# These lines must be present in /etc/apparmor.d/usr.sbin.unbound before the deny rule,
# otherwise Unbound will fail with "Permission denied" when loading its TLS certificates.

# Ensure remote-control TLS keys/certs exist
if [ ! -s /etc/unbound/unbound_server.key ] || \
   [ ! -s /etc/unbound/unbound_server.pem ] || \
   [ ! -s /etc/unbound/unbound_control.key ] || \
   [ ! -s /etc/unbound/unbound_control.pem ]; then
    echo "üîß Remote-control TLS files missing, running unbound-control-setup..."
    sudo unbound-control-setup
fi

# Fix ownership and permissions
echo "üîß Fixing ownership and permissions for remote-control TLS files"
sudo chown unbound:unbound /etc/unbound/unbound_server.* /etc/unbound/unbound_control.*
sudo chmod 600 /etc/unbound/unbound_server.key /etc/unbound/unbound_control.key
sudo chmod 640 /etc/unbound/unbound_server.pem /etc/unbound/unbound_control.pem

# AppArmor read‚Äërules block for Unbound remote‚Äëcontrol TLS key/cert files.
# Must be inserted before the deny line "audit deny /etc/unbound/unbound_control.{key,pem} rw,"
# Without these rules, Unbound fails to start with "Permission denied" on its TLS certs.

# Path to AppArmor profile for Unbound
PROFILE="/etc/apparmor.d/usr.sbin.unbound"

# AppArmor read‚Äërules block for Unbound remote‚Äëcontrol TLS key/cert files.
REQUIRED_TEXT="# ‚ö†Ô∏è inserted according to instructions in setup-unbound.sh in AppArmor read‚Äërules block for Unbound remote‚Äëcontrol TLS key/cert files
  /etc/unbound/unbound_server.key r,
  /etc/unbound/unbound_server.pem r,
  /etc/unbound/unbound_control.key r,
  /etc/unbound/unbound_control.pem r,
# end of inserted block "

TS="$(date +%Y%m%d-%H%M%S)"   # define timestamp once

# Check if the required text is present
if ! grep -Fq "$REQUIRED_TEXT" "$PROFILE"; then
    BACKUP="${PROFILE}.bak.${TS}"
    sudo cp "$PROFILE" "$BACKUP"

    cat <<EOF
‚úçÔ∏è AppArmor TLS cert read rules missing, preparing to insert
üìÇ Backup created at $BACKUP
‚û°Ô∏è Please open the profile with: sudoedit $PROFILE
‚ö†Ô∏è Then insert the following block BEFORE the line:
   # explicitly deny (and audit) attempts to write to the key files
   as the first audit deny appear after it.

$REQUIRED_TEXT

‚ö†Ô∏è When done, execute the present script again.
EOF
    exit 4
else
    echo "‚úÖ AppArmor TLS cert read rules already present ‚Äî verified at $TS"
fi

# Enable service only if not already enabled
if ! systemctl is-enabled --quiet unbound; then
    echo "üîß Enabling Unbound service"
    sudo systemctl enable unbound
fi

# Restart Unbound if config changed, otherwise try reload safely
if [ ! -f "$conf_file" ] || ! diff -q <(echo "$desired_conf") "$conf_file" >/dev/null; then
    echo "üîÑ Restarting Unbound (config changed)..."
    echo "‚û°Ô∏è Command: sudo systemctl restart unbound"
    sudo systemctl restart unbound
else
    echo "üîÑ Reloading Unbound (config unchanged)..."
    if command -v unbound-control >/dev/null; then
        echo "‚û°Ô∏è Command: sudo unbound-control reload"
        sudo unbound-control reload || {
            echo "‚ö†Ô∏è Reload failed, falling back to restart"
            sudo systemctl restart unbound
        }
    else
        echo "‚û°Ô∏è Command: sudo systemctl restart unbound (reload unsupported)"
        sudo systemctl restart unbound
    fi
fi

# Verify Unbound is responsive
if ! sudo unbound-control status >/dev/null 2>&1; then
    echo "‚ùå Unbound did not start correctly"
    exit 4
fi

# Final test queries to confirm resolution works
if ! command -v dig >/dev/null; then
    echo "‚ùå dig command not found, please install dnsutils/bind-utils"
    exit 5
fi

echo "üîç Testing Unbound resolution with dig (IPv4 loopback)..."
if ! ipv4_output=$(dig @127.0.0.1 google.com +short +time=2 +tries=1 2>&1); then
    echo "‚ùå Test query failed: dig @127.0.0.1 google.com +short +time=2 +tries=1"
    echo "Error output:"
    echo "$ipv4_output"
    exit 6
fi
if [ -z "$ipv4_output" ]; then
    echo "‚ö†Ô∏è IPv4 test query returned no result (possible upstream issue)"
else
    echo "‚úÖ IPv4 test query succeeded, google.com resolved to:"
    echo "$ipv4_output"
fi

echo "üîç Testing Unbound resolution with dig (IPv6 loopback)..."
if ! ipv6_output=$(dig @::1 google.com +short +time=2 +tries=1 2>&1); then
    echo "‚ùå Test query failed: dig @::1 google.com +short +time=2 +tries=1"
    echo "Error output:"
    echo "$ipv6_output"
    exit 7
fi

if [ -z "$ipv6_output" ]; then
    echo "‚ö†Ô∏è IPv6 test query returned no result (possible upstream issue)"
else
    echo "‚úÖ IPv6 test query succeeded, google.com resolved to:"
    echo "$ipv6_output"
fi

# DNSSEC validation test
echo "üîç Testing Unbound DNSSEC validation..."
if ! dnssec_output=$(dig @127.0.0.1 cloudflare.com +dnssec +short +time=2 +tries=1 2>&1); then
    echo "‚ùå DNSSEC test query failed: dig @127.0.0.1 cloudflare.com +dnssec +short +time=2 +tries=1"
    echo "Error output:"
    echo "$dnssec_output"
    exit 8
fi

if [ -z "$dnssec_output" ]; then
    echo "‚ö†Ô∏è DNSSEC test query returned no result (possible upstream issue)"
else
    echo "‚úÖ DNSSEC test query succeeded, cloudflare.com resolved with DNSSEC signatures:"
    echo "$dnssec_output"
fi

# Negative DNSSEC test (should fail validation)
echo "üîç Testing Unbound with deliberately broken DNSSEC domain..."
if ! bad_output=$(dig @127.0.0.1 dnssec-failed.org +dnssec +short +time=2 +tries=1 2>&1); then
    echo "‚úÖ As expected, dnssec-failed.org failed DNSSEC validation"
else
    echo "‚ö†Ô∏è Unexpected result: dnssec-failed.org returned data"
    echo "$bad_output"
    exit 9
fi

echo "üéâ Unbound recursive setup complete"
